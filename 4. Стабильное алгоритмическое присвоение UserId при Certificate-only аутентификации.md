Представим такую задачу - необходимо реализовать безопасный портал, в рамках которого пользователи были бы уверены
в том, что никакая персональная информация или иная идентифицирующая их информация не будет храниться и не может быть передана
или незаконно получена/украдена третьими лицами или организациями.
Рассмотрим проблему с точки зрения владельца подобного портала.

Начнем с простого - во-первых пользователю не следует никакой такой информации сохранять в своем профиле или иным
способом загружать на портал, но это пользовательский OpSec, владелец портала за него не отвечает.

Во-вторых, как мы уже сказали, все взаимодействия производятся при помощи сертификатов и это означает, что у каждого
пользователя будет доверенный сертификат. Соответственно, процесс выдачи сертификатов/подписания CSR, каким бы образом
он ни был реализован, в идеале не дожен оставлять никаких логов или следов. Таким образом мы уничтожаем информацию о том,
сколько сертификатов существует, что это за сертификаты, какие у них публичные ключи.

В третьих, если у нас нет информации о сертификатах пользователей, и мы ее намеренно нигде не храним, мы сможем, тем не
менее, аутентифицировать на основании Root CA, однако же встает вопрос - как реализовать авторизацию, то есть сопоставить данные, полученные
при аутентификации с тем, что хранится в нашей системе, например userId.

Как уже было замечено, мы не можем хранить соответствие сертификат-userId или публичный ключ-userId в нашей БД, так как при ее компрометации
эта информация уплывет, и в дальнейшем может быть сопоставлена с кокретным пользователями, на основании наличия у них
обнаруженных через утечку сертификатов. Так как мы не можем хранить данное соотношение в явном виде, возникает идея об алгоритмическом
формировании подобного UserId от данных аутентификации, которые при этом нигде не сохраняются.

Перечислим цели, которые хотелось бы достигунть подобным подходом:
1. Минимальное взаимодействие с аутентификационными данными на протоколе, минимизация риска утечки аутентификационных токенов.
    - в данном случае токены это пользовательские сертификаты и публичные ключи
    - на протоколе мы хотим очень быстро их использовать на этапе инициализации соединения и после забыть навсегда, до следующей аутентификации
    - и уж совершенно точно мы не хотим нигде их персистить на уровне нашего портала, ни в какой БД, логах и т.п.
2. Из данных, которые мы храним на портале, должно быть невозможно прямым способом вычислить данные аутентификации.
    - то есть из данных аутентификации (сертификат) наш портал может вычислить UserId, а вот обратно нет
    - таким образом, если у нас сольют UserId, то тривиальным образом сопоставить его сертификату не дожно быть возможным
3. Невозможность replay-атак на аутентификацию.
4. При известном пользовательском сертификате и его ключах, не должно быть возможным вычислить UserId, не имя полного
доступа к секретам портала.
    - из данных аутентификации (сертификат) наш портал может вычислить UserId, но только наш портал, и никакой другой
    актор и даже не сам пользователь.

Определив данные цели, можно предложить следующее решение, в виде следующего протокола и алгоритма вычисления UserId на стороне портала.

1. Инициализируем сессию mTLS, как обычно.
   - при этом получаем сертификат пользователя, который стандартным образом проверяется на доверенность черер Root CA.
2. Задаем пользователю челлендж - например подписать что-либо рандомное.
   - возможно это overkill, так как нечто подобное и так происходит на уровне mTLS.
   - просто хочется данный пункт указать явно, т.к. в этом состоит защита от replay
3. Затем пользователь присылает нам `секретный пакет` - его публичный ключ, закриптованный его же приватным ключом.
   - этот секрет портал может проверить, раскриптовав его публичным ключом, получив в результате тот же публичный ключ
4. Если все проверки сходятся, сервер конкатенирует, XOR-ит или инфм образом мерждит `секретный пакет` и `секрет портала`
   - от результата данной операции вычисляется SHA-256
   - а еще лучше, прогнать его через PBKDF2 секретное же количество итераций
5. Результат выполнения шага 4 - это и есть ваш UserId.