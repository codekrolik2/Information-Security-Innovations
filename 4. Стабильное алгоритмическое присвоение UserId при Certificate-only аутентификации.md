Представим такую задачу - необходимо реализовать безопасный портал, в рмаках которого пользователи были бы уверены
в том, что никакая персональная информация или идентифицирующая информация не будет храниться и не может быть передана
или незаконно получена/украдена третьими лицами или организациями.
Рассмотрим проблему с точки зрения владельца подобного портала.

Начнем с простого - во-первых пользователю не следует никакой такой информации сохранять в своем профиле или иным
способом загружать на портал, но это пользовательский OpSec, владелец портала за него не отвечает.

Во-вторых, как мы уже сказали, все взаимодействия производятся при помощи сертификатов и это означает, что у каждого
пользователя будет доверенный сертификат. Соответственно, процесс выдачи сертификатов/подписания CSR, каким бы образом
он ни был реализован, в идеале не дожен оставлять никаких логов или следов. Таким образом мы уничтожаем информацию о том,
сколько сертификатов существует, какие это сертификаты, какие у них публичные ключи.

В третьих, если у нас нет информации о сертификатах пользователей, и мы ее намеренно нигде не храним, мы сможем, тем не
менее, аутентифицировать на основании Root CA, однако же как реализовать авторизацию, то есть сопоставить данные, полученные
при аутентификации тем, что хранится в нашей системе, например userId.

Как уже было замечено, мы не можем хранить соответствие сертификат-id или ключ-id в нашей БД, так как при ее компрометации
эта информация уплывет, и в дальнейшем может быть сопоставлена с кокретным пользователями, на основании наличия у них
обнаруженных сертификатов. Так как мы не можем хранить данное соотношение в явном виде, возникает идея об алгоритмическом
формировании подобного UserId от данных аутентификации, которые при этом нигде не сохраняются.

Пронумеруюм цели, которых хотелось бы достигунть подобным подходом:
1. Минимальное взаимодействие с аутентификационными данными н протоколе, минимизация риска утечки аутентификационных токенов
    - в данном случае токены это пользовательские сертификаты и публичные ключи
    - на протоколе мы хотим очень быстро их использовать на этапе инициализации соединения и после забыть навсегда, до следующей аутентификации
    - и уж совершенно точно мы не хотим нигде их персистить на уровне нашего портала, ни в какой БД и т.п.
2. Из данных, которые мы храним на портале, должно быть невозможным прямым способом вычислить данные аутентификации
    - то есть из данных аутентификации (сертификат) наш портал может вычислить UserId, а вот обратно нельзя
    - таким образом, если у нас сольют UserId, то тривиальным образом сопоставить его сертификату не дожно быть возможным
3. Невозможноть replay-атак на аутентификацию
4. При известном польщовательском сертификате и его ключах, не должно быть возможным вычислить UserId, не имя полного
доступа к секретам портала
    - из данных аутентификации (сертификат) наш портал может вычислить UserId, но только наш портал, и никакой другой
    актор и даже не сам пользователь.

Определив цели, можно предложить следующее решение, в виде