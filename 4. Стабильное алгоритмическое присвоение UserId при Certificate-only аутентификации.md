Представим такую задачу - необходимо реализовать безопасный портал, в рамках которого пользователи были бы уверены
в том, что никакая персональная информация или иная идентифицирующая их информация не будет храниться и не может быть передана
или незаконно получена/украдена третьими лицами или организациями.
Рассмотрим проблему с точки зрения владельца подобного портала.

Начнем с простого - во-первых пользователю не следует никакой такой информации сохранять в своем профиле или иным
способом загружать на портал, но это пользовательский OpSec, владелец портала за него не отвечает.

Во-вторых, как мы уже сказали, все взаимодействия производятся при помощи сертификатов и это означает, что у каждого
пользователя будет доверенный сертификат. Соответственно, процесс выдачи сертификатов/подписания CSR, каким бы образом
он ни был реализован, в идеале не дожен оставлять никаких логов или следов. Таким образом мы уничтожаем информацию о том,
сколько сертификатов существует, что это за сертификаты, какие у них публичные ключи.

В третьих, если у нас нет информации о сертификатах пользователей, и мы ее намеренно нигде не храним, мы сможем, тем не
менее, аутентифицировать на основании Root CA, однако же встает вопрос - как реализовать авторизацию, то есть сопоставить данные, полученные
при аутентификации с тем, что хранится в нашей системе, например userId.

Как уже было замечено, мы не можем хранить соответствие сертификат-userId или публичный ключ-userId в нашей БД, так как при ее компрометации
эта информация уплывет, и в дальнейшем может быть сопоставлена с конкретными пользователями, на основании наличия у них
обнаруженных через утечку сертификатов. Так как мы не можем хранить данное соотношение в явном виде, возникает идея об алгоритмическом
формировании подобного UserId от данных аутентификации, которые при этом нигде не должны сохраняться.

Перечислим цели, которые хотелось бы достигнуть подобным подходом:
1. Минимальное взаимодействие с аутентификационными данными на протоколе, минимизация риска утечки аутентификационных токенов.
    - в данном случае токены это пользовательские сертификаты и публичные ключи
    - на протоколе мы хотим очень быстро их использовать на этапе инициализации соединения и после забыть навсегда, до следующей аутентификации
    - и уж совершенно точно мы не хотим нигде их персистить на уровне нашего портала, ни в какой БД, логах и т.п.
2. Из данных, которые мы храним на портале, должно быть невозможно прямым способом вычислить данные аутентификации.
    - то есть из данных аутентификации (сертификат) наш портал может вычислить UserId, а вот обратно нет
    - таким образом, если у нас сольют UserId, то тривиальным образом сопоставить его сертификату не дожно быть возможным
3. Невозможность replay-атак на аутентификацию.
4. При известном пользовательском сертификате и его ключах, не должно быть возможным вычислить UserId, не имя полного
доступа к секретам портала.
    - из данных аутентификации (сертификат) наш портал может вычислить UserId, но только наш портал, и никакой другой
    актор и даже не сам пользователь.

Определив данные цели, можно предложить следующее решение, в виде протокола и алгоритма вычисления UserId на стороне портала.

1. Инициализируем сессию mTLS, как обычно.
   - при этом получаем сертификат пользователя, который стандартным образом проверяется на доверенность через Root CA.
2. Задаем пользователю челлендж - например подписать что-либо рандомное.
   - опционально, так как нечто подобное и так происходит на уровне mTLS.
   - просто хочется данный пункт указать явно, т.к. в этом состоит защита от replay
3. Затем пользователь присылает нам `секретный пакет` - его публичный ключ, закриптованный его же приватным ключом.
   - этот секрет портал может проверить, раскриптовав его публичным ключом, получив в результате тот же публичный ключ
4. Если все проверки сходятся, сервер конкатенирует, XOR-ит или иным образом мерждит `секретный пакет` и `секрет портала`
   - от результата данной операции вычисляется SHA-256
   - а еще лучше, прогнать его через PBKDF2 секретное же количество итераций
5. Результат выполнения шага 4 - это и есть ваш UserId.

Рассмотрим, каким образом данный подход достигает вышеописанных целей.
1. Минимальное взаимодействие с аутентификационными данными на протоколе
   - После вычисления UserId мы можем полностью удалить сертификат из памяти. Для авторизованной и безопасной коммуникации 
достаточно AES-ключа TLS и вычисленного UserId.
2. Из данных, которые мы храним на портале, должно быть невозможно прямым способом вычислить данные аутентификации.
   - так как мы не персистим ни публичные ключи, ни сертификаты, в т.ч. в логах, а при инициализации каждого соединения 
они должны уничтожаться мгновенно после авторизации даже из оперативной памяти, утечка этих данных из хранилищ портала невозможна.
   - При полной компрометации портала и перехвате всего управления, конечно, эти данные можно будет перехватить за какое-то 
время из новых сессий, но тут уж ничего не поделаешь, если компрометаци портала полная.
   - В данном случае, однако же, мы говорим не о чем-то серьезном, вроде утчки email или номере телефона, а о 
сертификатах и публичных ключах, что само по себе представляет минимальный риск, и их очень легко (и даже нужно) регулярно менять.
3. Невозможность replay-атак на аутентификацию.
   - хотя пользовательский `секретный пакет` теоретически возможно украсть, пусть и крайне затруднительно, и затем 
переиспользовать, тем не менее шаги 1 и 2 предотвращают возможность replay-атак без полной компрометации 
пользовательских ключей 
4. При известном пользовательском сертификате и его ключах, не должно быть возможным вычислить UserId
   - Так как на шаге 4 мы модифицируем `секретный пакет`, соединяя его с неизвестным никому `секретом портала`, прежде 
чем вычислять UserId, соответственно, для повторения вычисления UserId необходимо знать `секрет портала`, а он известен 
только лишь порталу
