Обратная сервисная аутентификация
---
Используем Vault / K8s в качестве примера.
Vault имеет такую фишку, как Kubernetes authentication, на чем основана работа технологий, как Vault Agent
Sidecar Injector, и всего связанного с тем, как в наше время секреты достаются из Vault и внедряются в контейнер
init time.

Это рабочий подход, но работает только на pull. Если мы что-то откуда-то пуллим, а особенно, если кто-то это
что-то где-то сформировал, а потом туда положил вручную, то шансы таковы, что эти секреты уже украдены до
нас, к примеру специально обученным специалистом из гугла, у которого бекдор к вашему GKE и Chrome.

Поэтому единственное, что можно пушить и пуллить - так это публичные ключи (как правило, в виде сертов), и
то крайне осторожно.

Так что, если наш сервис это не микросервис, проксирующий туда-сюда запросы, а нормальный сервис, который
что-то делает полезное, то ситуация такова, что не ему нужны секреты, а его секреты нужны тем, кто к нему
хочет получить доступ. Для такого сервиса было бы глупо просить админа установить пароль, чтобы потом везде
его шарить, чтобы шпион его мог украсть и подменить endpoint с помощью MITM. Конечно, сервис должен сам
себе создать сертификат и расшарить только публичный ключ, и принимать траффик только через TLS. От кого
ему принимать траффик, а от кого нет - поговорим позже.

Таким образом, получается “обратная” аутентификация или “обратное” распространение секретов. Не сервис
получает какие-то скомпрометированные токены непонятно кем и как созданные, а наоборот, публикует свой
публичный ключ, созданный на ините и пока что даже не скомпрометированный. Вопрос тут возникает не как
его сгенерировать, или даже как избежать его компрометации непосредственно на облаке (что тоже
сверхзадача, но и это оставим также за скобками), а как его опубликовать - ведь там, куда вы публикуете,
киберпреступник может подменить на свой сертификат и опять запустить MITM.

Vault Agent тут совсем не при чем, он может только пуллить текстовый трэшак из волта, который нельзя считать
пригодным к употреблению в 2025-м, просто выкидываем Agent и никогда не используем. Тем не менее, тут нам
пригождается Kubernetes auth, через которую мы с помощью клиента можем авторизоваться в Vault (Vault сам по
себе не бесполезен, а бесполезны только секреты, которые в него закидывают наивные обыватели, т.к. они
украдены были все еще с их машин). Сделаем допущение о том, что эта технология работает как задумано,
иначе это вообще никак не сделаешь. Так вот, часть с закидыванием публичного ключа в Vault мы резко и
неожиданно для негодяев выполнили на непредсказуемом создании и ините нашего контейнера, используя
вышеописанный способ. Теперь ключ лежит в волте, а т.к. у нас разрешение только на создание, то даже если
преступник перехватит какие-то JWT в кубере, то уж поздно, publish сделан (TODO: проверить это утверждение
на практике).

Следующая часть - это кому надо этот ключ получить, да и помимо ключа там что-то вроде сервис дискавери, IP
и т.д. с подписью, конечно же. Кто надо - получает, аутентифицируясь в Vault, конечно же, тоже с сертификатом.
И не с простым сертификатом, который любой преступник может слямзить так же легко, как и любой текстовый
файлик с вашими паролями с вашего десктопа, а с PKCS#11 сертификатом, конечно же. Так как все Vault
клиенты профинансированы членами заинтересованных групп, они, конечно же, не поддерживают PKCS#11
(запрашивать бессмысленно, по понятным причинам, они еще и расскажут вам, как это устарело и что сейчас,
вообще, модно и молодежно попросту отдавать им все свои секреты, чтобы хранить на их сервере, но вы знаете
куда их отчислять), так что это нужно сделать по REST API. Так как мы все продумали, то это был wrapped token,
и если преступник его как-то перехватил в волте, то нам покажут кукиш, и мы нанесем термоядерный удар по
контейнеру еще до начала его использования; а если взяли мы, то кукиш получит уже преступник, (то есть Vault
далеко не бесполезная часть этой схемы).

Теперь, в идеальном мире, мы достоверно получили тот самый ключ от нашего сервиса, и он достоверно не был
подменен кибер-бандитами на проводе, так что MITM нам уже не подсунешь; и нужно скорее начинать его
использовать, пока его не вычислили через какой-нибудь квантумный процессор или не взломали нашконтейнер. 
У нас есть клиентский PKCS#11 серт, поэтому наш сервис каких попало массивно порт-сканирующих
кибернегодяев не впустит, т.к. знает наш серт еще до инсталла и использует, как и все свободное от инфекции,
mTLS. Но вся эта настройка лишь временная мера, и надо ее регулярно обновлять, периодически ротируя и
создавая новые сервисы и новые серты. Хоть каждую минуту или хоть каждое новое соединение, но это
малопрактично, конечно; следует найти подходящее практическое решение (Istio делает раз в день, к примеру).
