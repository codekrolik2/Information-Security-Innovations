# Архитектура сетевой безопасности для Desktop Environment

## 1. Введение

В наше время неуклонно увеличивается количество цифровых угроз - в первую очередь, связанных с сетевыми 
технологиями. Обеспечение сетевой безопасности является краеугольным камнем технологической стабильности 
современного мира. 

Более профессиональная ниша дата центров и расположенных в них серверов имеет достаточное 
количество доступных ей квалифицированных человеческих ресурсов и финансирования для обеспечения наивысшей 
степени безопасности, при этом крупные игроки, особенно масштабные облачные провайдеры, как Amazon, Google, и т.д.
даже разрабатывают собственный проприетарный технологический стек, включающий не только все уровни ПО, но и 
аппаратную/железную часть; и даже у самого простого оператора ДЦ всегда на зарплате команда сетевой безопасности,
постоянно мониторящая сетевые аномалии и угрозы, и готовая мгновенно реагировать на любые инциденты.  
Также, у большинства софтверных компаний, даже не имеющих собственного железа и хостящихся на облаке, имеется 
команда безопасников, следящих за несанкционированными проникновениями в их инфраструктуру.  
Для достижения профессионального уровня специалисты по безопасности учатся длительное время, и за свою экспертизу
получают высокую зарплату. Информационная безопасность - это очень серьезно и очень сложно.

Конечно, для отдельно взятого домохозяйства с подключением к интернет нереалистично нанять даже одного 
специалиста по безопасности, и крайне затруднительным видится налаживание какой-либо существенной
инфраструктуры сетевого мониторинга, по причине дороговизны и сложности ее обслуживания.
Заметим при этом, что взлому подвергаются не только конечные пользовательские системы, но и вообще, все,
что подключается к сети - IP камеры, многочисленные в наше время устройства IoT, и особенно опасно - само 
сетевое оборудование, модемы, свитчи и раутеры. Все это также верно и для общественных сетей, например WiFi в вашей 
любимой кофейне, либо сам по себе ставший скомпрометированным, или же ваше подключение не к самому этому WiFi, а к его 
имперсонации злонамеренным актором.  
В крайне сложных ситуациях ваш провайдер домашнего интернета по тем или иным причинам может быть заинтересован во 
взломе ваших систем.  

Обобщая вышесказанное, ваше подключение к провайдеру, с его согласия или без (про ваше я молчу), может перекоммутироваться через 
т.н. MITM, то есть абсолютно весь траффик, который к вам приходит, может быть заспуфлен и превращен в кибератаку 
миллионом различых способов. При этом, если только вы не миллиардер, то у вас нет ни денег, ни ресурсов (в т.ч. времени), 
ни экспертизы для обнаружения атак или патчинга/восстановления систем. К сожалению, существование уязвимости не всегда 
означает существование патча, эту уязвимость исправляющего, особенно для устаревшего оборудования.

## 2. Безопасный Desktop Environment

В данной статье мы покажем прицип устройства безопасного десктоп-окружения, и техники, применимые для получения
высокой безопасности рабочего окружения, доступные для применения отдельно взятому человеку, без поддержки командой ИБ.  
В данной работе я попытался использовать как можно более простые и общеизвестные средства, доступные с открытым исходным 
кодом в стандартной поставке современных Linux-систем.

Общая идея раутинга траффика состоит в том, чтобы создать уровень софтверного раутинга поверх физического соединения.
В данном примере мы осуществляем это через локальный SOCKS прокси сервер, за которым скрывается устраивающая вас 
технология софтверного раутинга, ее мы умышленно не специфицируем.

Большая картина будет выглядеть примерно так:

![6. big picture.png](6.%20big%20picture.png)

Как видно из диаграммы, в данном случае HostOS выполняет следующие функции:
1. SOCKS-сервер, через который пользовательский траффик коммутируется к нашему доверенному Entry Point 
на Интернете. Естествнно, что нешифрованный SOCKS-порт здесь исключительно для внутреннего использования.
2. Гипервизор для пользовательских VM, в т.ч. графический интерфейс для возможности пользовательского взаимодействия 
с Guest OS через UI (в нашем примере QEMU/KVM).
3. Сетевой брандмауэр для недопущения ненужного траффика, как входящего, так и исходящего. 
(в нашем примере мы используем IPTables)

В свою очередь, VM, исполняющаяя GuestOS с пользовательскими workloads также имеет IPTables, что вкупе 
с IPTables на HostOS составляет двойной щит из брандмауэров.

Далее рассмотрим каждый из компонентов этой системы.

## 3. QEMU/KVM
Ключевым компонентом нашей системы является платформа виртуализации, в данном случае мы используем QEMU/KVM.
Помимо популярности этой платформы, важным качеством видится легковесность и простота настройки и использования.

### 3.1. Установка QEMU/KVM

На HostOS QEMU/KVM ставится просто:  
`sudo apt install qemu-kvm`  
После установки станут доступными программы `qemu-system-x86_64`, `qemu-img`.

### 3.2. Создание VM с Guest OS

#### 3.2.1. Создадим виртуальный диск для нашей VM  
`qemu-img create -f qcow2 disk.qcow2 20G`  

Здесь:  
    *-f qcow2* - формат виртуального диска, QEMU Copy On Write v2  
    *disk.qcow2* - имя файла виртуального диска  
    *20G* - размер виртуального диска, 20 Gb. (мин. для OS Debian 10Gb, Ubuntu/Windows10 15Gb).

#### 3.2.2. Произведем установку OS на нашу VM с ISO файла  
`qemu-system-x86_64 -m 4096 -enable-kvm -cpu host -smp 8 -cdrom os.iso -hda disc.qcow2 -boot d`  

Здесь:  
    *-m 4096* - 4Gb оперативки  
    *-enable-kvm* - разрешаем KVM для лучшей производительности  
    *-cpu host* - используем хостовые CPU, вместо эмуляции  
    *-smp 8* - 8 ядер CPU  
    *-cdrom os.iso* - присоединяем виртуальный CD-ROM в виде ISO-файла с установщиком OS  
    *-hda disc.qcow2* - присоединяем ранее созданный виртуальный жесткий диск  
    *-boot d* - загружаемся с CD-ROM  
Далее, устанавливаем OS. Можно любую, но в описании Guest OS ниже мы будем подразумевать Linux с поддержкой IPTables.  
Имеет смысл облегчить HostOS, путем удаления всех компонентов, без которых возможно корректное исполнение 
функций, описанных в параграфе 2. При этом также уменьшится потенциальный attack surface на Host OS.

### 3.3. Запуск и операции на VM с Guest OS

#### 3.3.1 Собственно запуск

Для запуска используем команду  
`qemu-system-x86_64 -m 4096 -enable-kvm -cpu host -smp 8 -hda disc.qcow2 -snapshot`

Здесь:  
*-snapshot* - не сохранять изменения, произошедшие в процессе ее работы на жесткий диск, 
сходно с принципом работы OS Tails.

#### 3.3.2 Сетевое взаимодействие между Host OS и Guest OS

По умолчанию сеть Guest OS создается в режиме User-Level Networking (a.k.a. slirp).  
Это самый простой и легкий в настройке способ сетевого взаимодействия, что выражается в следующем:
- На Host OS не создается сложной виртуальной сетевой структуры, требующей отдельной настройки (тоже непростой).
- Для Host OS траффик от VM выглядит как траффик от локальной программы, что позволяет использовать те же самые 
правила iptables для регулирования как траффика Host OS и его приложений, так и траффика любой из Guest OS, 
единообразно.
- Не нужно вручную устанавливать различные MAC-адреса для каждой Guest OS/VM.
- Для получения IP Guest OS использует встроенный в QEMU DHCP сервис, автоматически.
- Доступ к Host OS из Guest OS также происходит очень просто, по IP 10.0.2.2
- Подробнее здесь: https://www.linux-kvm.org/page/Networking

#### 3.3.3 Неизменяемые виртуальные диски

Важной функцией KVM является возможность запускать VM с опцией `-snapshot`, что позволяет сохранять диск с установленной
OS неизменным. Так, даже если в рамках рабочей сессии произойдет заражение Guest OS, то это зараженное состояние не 
будет сохранено между перезапусками, и следующий запуск будет произведен с оригинального незараженного жесткого диска.
Конечно, это не является панацеей, и заражение все еще таит в себе угрозы.
1) В рамках зараженной сессии все еще возможно будет что-то утащить.
2) Возможно и существование malware с изощренной VM-aware логикой, содержащих payloads, способных заразить Host OS, 
но скажем так, 99% из того, что используется "коммерческими" хакерами, не имеет подобного функционала.  
3) Информация о наличии уязвимостей может использоваться в дальнейшем, увеличивая вероятность и результативность 
повторных атак на будущие сессии.
4) Вывод: Почаще перезапускайте Guest OS. В режиме Snapshot для скорости просто закрывайте окно QEMU крестиком.  

Для того, чтобы на 100% исключить возможность изменения образа виртуального диска, его можно запускать 
с Read-Only носителя, например с CD-ROM или внешнего жесткого диска с защитой от записи.  
Как минимум, мы рекомендуем дать 
файлам дисков доступ только на чтение. Это исключит случайный запуск VM без опции snapshot.  
Для этого используйте команду  
`chmod 444 *.qcow2`

Также заметим, что виртуальные диски VM представляют собой файлы и являются переносимыми; т.е. если хранить их на внешнем носителе, то они
переживают уничтожение Host OS или даже полное обновление аппаратной системы, исполняющей Host OS.
Соответственно, можно запускать эти VM на разных компьютерах с совместимой Host OS.

#### 3.3.4 Персистентное состояние пользовательских данных

Возникает вопрос: если на диске Guest OS теперь все эфемерно и ничего не сохраняется между перезапусками, как же тогда 
быть с пользовательскими данными, произведенными в рамках рабочей сессии? Ведь их нельзя терять.  
Так как мы живем в эпоху победившего Web и сетевых сервисов, мы рекомендуем использовать комбинацию сервисов 
Internet и сервисов, которые будут исполняться на HostOS или в локальной сети. Здесь мы не будем уходить в детали и 
конкретные примеры, пусть каждый выбирает конкретные сервисы и методики на свой вкус.

#### 3.3.5 Работа с USB

Несмотря на то, что в наше время есть сервисы почти что для всего, в некоторых случаях без использования USB-устройств на 
Guest OS не обойтись. Например, аутентификация на ваших сервисах при помощи криптографических токенов.
USB можно подключать на холодную, при запуске VM (что непрактично и долго), и на горячую - во время ее работы.
Горячее подключение выполняется при помощи следующих команд:  

1) Вначале на Host OS необходимо идентифицировать интересующее вас устройство, исполнив команду:  
`lsusb`


2) Затем на VM создаем USB  
High speed:  
`(qemu) device-add usb-ehci,id=ehci`  
Full speed:  
`(qemu) device-add qemu-xhci,id=xhci`  


3) После чего присоединяем само USB устройство  
`(qemu) device-add usb-host,hostbus={BUS},hostaddr={ADDR}},id=yubikey`  
(Здесь `hostbus` и `hostaddr` следует взять из вывода команды `lsusb`)

Для того, чтобы это работало, надо запустить `qemu` через `sudo`. Заметим, что выше `qemu` мы запускали без `sudo`.

#### 3.3.6 Обновление Guest OS

Важно также периодически обновлять используемый софт, что несовместимо с запуском в режиме `snapshot`.  
Для подобных операций просто запускайте VM без этой опции, чтобы создать следующую версию вашего образа.
Рекомендуем в таких случаях также полностью копировать виртуальный диск, чтобы не утерять предыдущее состояние.

#### 3.3.7 Сознательно не используем `virt-manager` в нашем примере

Хотя это и очень удобный UI-интерфейс, простой в использовании, но в том, что именно он делает под капотом,
крайне сложно разобраться.  
Для понимания сложности, можно для теста запустить через него VM и посмотреть, что именно он запускает, выполнив 
команду `ps`. Как именно там все это настраивать через UI для получения нужного нам эффекта, представляется 
выходящим за рамки данной работы или моих интересов.  
Кроме того, он сразу же при запуске требует `sudo`, а это не во всех случаях обязательно.


## 4. Пример настройки IPTables

> Disclaimer 1: Утилиты *tables, включая iptables, устарели, и были заменены nftables, поэтому, если у вас nftables,
> приведенные ниже правила следует адаптировать.

> Disclaimer 2: IPTables сам по себе не сохраняет свои настройки при перезагрузке, но существуют способы его 
> персистентной конфигурации, которые мы не будем затрагивать в данной работе.

> Disclaimer 3: syslog тоже заменили на что-то там, и лично я это решительно осуждаю.

### 4.1 Host OS

```
iptables -t nat -F
ip6tables -t nat -F
iptables -t mangle -F
ip6tables -t mangle -F
iptables -F
ip6tables -F
iptables -X
ip6tables -X

iptables -P OUTPUT DROP
ip6tables -P OUTPUT DROP
iptables -P INPUT DROP
ip6tables -P INPUT DROP
iptables -P FORWARD DROP
ip6tables -P FORWARD DROP

# ================== external router port ==================
iptables -A OUTPUT -p tcp --dport {PORT} -d {IP_ADDRESS} -j ACCEPT
iptables -A INPUT -p tcp --sport {PORT} -s {IP_ADDRESS} -m state --state ESTABLISHED,RELATED -j ACCEPT
# ================ END external router port ================


# ==================== local proxy port ====================
# local client
iptables -A OUTPUT -o lo -p tcp --dport {PROXY_PORT} -d 127.0.0.1 -s 127.0.0.1 -j ACCEPT
iptables -A INPUT -i lo -p tcp --sport {PROXY_PORT} -s 127.0.0.1 -d 127.0.0.1 -m state --state ESTABLISHED,RELATED -j ACCEPT

# local server
iptables -A OUTPUT -o lo -p tcp --sport {PROXY_PORT} -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT
iptables -A INPUT -i lo -p tcp --dport {PROXY_PORT} -d 127.0.0.1 -s 127.0.0.1 -j ACCEPT
# ================== END local proxy port ==================
```

### 4.2 Guest OS

```
iptables -t nat -F
ip6tables -t nat -F
iptables -t mangle -F
ip6tables -t mangle -F
iptables -F
ip6tables -F
iptables -X
ip6tables -X

iptables -P OUTPUT DROP
ip6tables -P OUTPUT DROP
iptables -P INPUT DROP
ip6tables -P INPUT DROP
iptables -P FORWARD DROP
ip6tables -P FORWARD DROP

# ================== Host OS proxy port ==================
iptables -A OUTPUT -p tcp --dport {PROXY_PORT} -d 10.0.2.2 -j ACCEPT
iptables -A INPUT -p tcp --sport {PROXY_PORT} -s 10.0.2.2 -m state --state ESTABLISHED,RELATED -j ACCEPT
# ================ END Host OS proxy port ================
```

### 4.3 Выявление прочих портов

В некоторых случаях, вашей Host OS могут быть необходимы и другие открытые порты для работы.
Для отладочного выявления заблокированного траффика можно использовать настройки iptables, приведенные ниже.  
Отладочный вывод пишется в syslog.

```
# Log all dropped packages, debug only.
iptables -N logging
iptables -A INPUT -j logging
iptables -A OUTPUT -j logging
iptables -A logging -m limit --limit 2/min -j LOG --log-prefix "IPTables general: " --log-level 7
iptables -A logging -j DROP

ip6tables -N logging
ip6tables -A INPUT -j logging
ip6tables -A OUTPUT -j logging
ip6tables -A logging -m limit --limit 2/min -j LOG --log-prefix "IPTables general: " --log-level 7
ip6tables -A logging -j DROP
```

## 5. Важные замечания
5.1) Raw Sockets   
Ограничения IPTables не распространяются на Raw Sockets (например, dhclient). Как по мне, то это дыра в дизайне 
безпасности, но тем не менее в настоящий момент все работает именно так, могу лишь напомнить об этом.


5.2) Расширение сетевой функциональности Guest OS.  
Данный пример предполагает доступ Guest OS к сети через SOCKS5 прокси сервер на Host OS.
Легче всего это настроить в браузере Mozilla Firefox (UI settings), немного сложнее в Chrome(ium) 
(command line parameter --proxy-server).
Заметим, что эти браузеры туннелят запросы с неотрезолвленными именами хостов, и потому работают и без DNS-сервера,
что поддерживается протоколом SOCKS5, который может делать DNS resolution на стороне сервера.

Однако, большинство программ не поддерживает SOCKS5 протокол. Существуют средства для перенаправления траффика любых 
приложений через SOCKS5, такие как `redsocks`, `proxychains`, `tun2socks`, но все они перенаправляют сетевые пакеты,
в которых есть адрес, но не hostname. Поэтому для их работы нужен DNS-сервер, т.к. в этом случае хостнеймы им
тем или иным способом требуется резолвить локально. Для этого имеет смысл запустить на Host OS также и DNS сервер.


5.3) Управление паролями  
У нас теперь может быть много OS, VM, и много паролей к ним и к, возможно, их зашифрованным дискам.
Эффективное управление паролями выходит за рамки данной работы, но использую этот случай, чтобы упомянуть 
свою недавнюю разработку - хардверный менеджер паролей `Phraser` [(GitHub)](https://github.com/flower-org/phraser), 
который работает, эмулируя USB-клавиатуру.


## APPENDIX A. Мое личное Biased Opinion по поводу сравнения с существующими системами - Tails, Qubes OS  
Далее махровое ИМХО, но оно такое:


- Tails нельзя кастомизировать, а мои VM-ки можно. Более того, на моих VM-ках можно запускать также и сам Tails.
Хотя, следует признать, что для исключения риска зараженной HostOS, Tails следует запускать саму по себе. Но в таком 
случае существует риск эксплуатации уязвимостей уже в самой Tails. Тут вам судить, чему же вы больше доверяете.

- Попробовав Qubes, пришел к выводу, что она какая-то вся нестандартная, нестабильная и сложная для понимания 
и настройки (за пределами стандартных документированных use cases). Пытался заменить в ней Tor VM на свою 
прокси и, безуспешно потратив на это дни, забросил.  
Т.к. она не имеет широкого adoption и review, также нельзя исключать, что на этом этапе скомпрометирована через алчных 
инсайдеров всеми, кому еще было не лень, и все бэкдоры найдут не раньше момента, когда и если она начнет 
править миром.  
Я же в своей работе использовал мейнстримовые устоявшиеся технологии, widely adopted and backed by major 
players. Эти технологии стабильны и непрестанно мониторятся профессиональными коммьюнити на баги и уязвимости. 
Знание этих систем ценно и само по себе, за пределами данного конкретного применения.  
В то же время, Qubes - это уникальное, сложное и не переиспользуемое знание, ее стандарт надо долго 
изучать, и результат такого обучения не будет иметь ценности вне парадигмы Qubes.
